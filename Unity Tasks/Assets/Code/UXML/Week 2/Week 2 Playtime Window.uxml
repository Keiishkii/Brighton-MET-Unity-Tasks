<ui:UXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" noNamespaceSchemaLocation="../../../../UIElementsSchema/UIElements.xsd" editor-extension-mode="False">
    <Style src="project://database/Assets/Code/USS/TaskViewer.uss?fileID=7433441132597879392&amp;guid=7f715e606be842898b63a5a4523e7fc1&amp;type=3" />
    <ui:VisualElement name="Container" style="flex-grow: 1; justify-content: flex-start; align-items: center; margin-top: 0; margin-right: 0; margin-bottom: 0; margin-left: 0; width: 100%; height: 100%; padding-top: 50px; padding-right: 50px; padding-bottom: 50px; padding-left: 50px;">
        <ui:ScrollView style="padding-top: 50px; padding-right: 50px; padding-bottom: 50px; padding-left: 50px; border-top-left-radius: 100px; border-top-right-radius: 100px; border-bottom-right-radius: 100px; border-bottom-left-radius: 100px; border-top-width: 5px; border-right-width: 5px; border-bottom-width: 5px; border-left-width: 5px; border-left-color: rgb(255, 255, 255); border-right-color: rgb(255, 255, 255); border-top-color: rgb(255, 255, 255); border-bottom-color: rgb(255, 255, 255); background-color: rgba(0, 0, 0, 0.67);">
            <ui:VisualElement name="GameViewContainer" style="flex-grow: 0; -unity-text-align: upper-center; width: auto; right: auto; left: auto; align-items: center; padding-top: 25px; padding-right: 25px; padding-bottom: 25px; padding-left: 25px; border-top-left-radius: 50px; border-top-right-radius: 50px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; border-left-color: rgb(255, 255, 255); border-right-color: rgb(255, 255, 255); border-top-color: rgb(255, 255, 255); border-bottom-color: rgb(255, 255, 255); border-top-width: 5px; border-right-width: 5px; border-bottom-width: 5px; border-left-width: 5px; height: auto; background-color: rgba(0, 0, 0, 0.85);">
                <ui:VisualElement name="GameWindowDisplay" style="flex-grow: 0; flex-shrink: 0; width: 1600px; height: 400px; background-image: url(&quot;project://database/Assets/Assets/RenderTexture/Game%20Window%20Render%20Texture.renderTexture?fileID=8400000&amp;guid=0517f62ff63c4889abefd94b877ed8f0&amp;type=2#Game Window Render Texture&quot;); border-top-left-radius: 25px; border-top-right-radius: 25px; border-bottom-right-radius: 0; border-bottom-left-radius: 0; border-top-width: 0; border-right-width: 0; border-bottom-width: 0; border-left-width: 0; background-color: rgb(51, 51, 51);" />
            </ui:VisualElement>
            <ui:TabView>
                <ui:Tab label="Overview" name="0-Overview">
                    <ui:Label text="Last week you had a go at some programming basics, this week we will try and put those into practice.&#10;&#10;The goal for the end of the day will be for you to be able to &quot;fix&quot; / &quot;develop&quot; the little game I have put together above.&#10;We&apos;ll walk through some basic setup for movement, hazards, and finally end on adding in some audio.&#10;&#10;Once you are done with these tasks I advise you have a play at taking them further, making your own level or adding in some enemies or objects yourself!" name="Label" />
                </ui:Tab>
                <ui:Tab label="Task 1" name="1-Rigidbody">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label text="Task Objective: Add a Rigidbody2D component to the player" name="Objective" class="task-objective" />
                    </ui:VisualElement>
                    <ui:Label text="Right now our &quot;player&quot; is effectivly an empty game object with a sprite attached to it.&#10;Our first job is to try and get this player actually interacting with the world in some way, luckily Unity has us covered with the RigidBody2D component.&#10;&#10;A rigidbody is effectivly &quot;something that has physics simulated on it, that acts a a single uniform object&quot; i.e. it wont break or deform.&#10;Try adding this component and pressing play, see what happens?&#10;&#10;Once you&apos;ve tried this, check Task 2, it will explain what you see." name="Label" />
                </ui:Tab>
                <ui:Tab label="Task 2" name="2-Colliders">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label text="Task Objective: Add a BoxCollider2D to the Player GameObject" name="Objective" class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label text="If you tried out the last last in play mode, you might have noticed our player character fall through the ground and disapear off into the void.&#10;What happened? Gravity!&#10;&#10;As I said in the last task, the RigidBody2D component is designed to apply physics to GameObjects, as such gravity was now acting on our player and making them fall.&#10;This is great, but how do we stop it from falling through the floor?&#10;&#10;To do this, we will need to add one more component, a BoxCollider2D.&#10;&#10;Colliders act as the solid part of a rigid body. Its worth considering that just because something is visible (2D or 3D) doesn&apos;t actually mean it has collision, or even if it does, that collider doesn&apos;t have to match the shape of the object visually (think invisible walls in games that look like you can easily jump over them)." name="Label" />
                </ui:Tab>
                <ui:Tab label="Task 3" name="3-Input">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label text="Task Objective: Create a custom player script and add movement." name="Objective" class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label text="Now that the player is experiancing physics we can start looking into adding some player controlled movement.&#10;To do this, were going to want to create our own scripts. &#10;&#10;A script or MonoBehaviour is just a custom component, the sort of thing you where working on last week. Go to the player and select:&#10;&#x9;&quot;Add Component &gt; New Script&quot;&#10;&#x9;And call this new script &quot;Player&quot;" name="Label" />
                    <ui:Label text="This will add a new component to the player that we can write some code in.&#10;After opening up this script, the first thing we are going to want to do is create an Update function, if their isn&apos;t one already.&#10;&#10;As we learnt from the execution order part of last weeks lesson, Unity calls specific functions within MonoBehaviours at specific times automatically.&#10;&#10;We can use to check if the player is pressing a button and if so perform an action.&#10;There are multiple different ways you can read input from Unity, for now we will use the old method from the Input class." name="Label" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="bool down = Input.GetKeyDown(KeyCode.Space);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="The GetKeyDown function, shown above returns a boolean, true or false, depending on whether the key supplied as the parameter was KeyCode is pressed this frame." name="Label" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="bool held = Input.GetKey(KeyCode.Space);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="GetKey is very similar however returns true if the key is still held. &#10;&#10;We using these functions we can now read player input, however that does not solve the moving problem. To do this we are going to want to turn back to our friend the RigidBody2D component. &#10;&#10;Accessing other components in a script is fairly easy, if we know the GameObject our custom “Player” scripts resides on also contains a RigidBody (or really any component). We can use:" name="Label" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="RigidBody2D rigidbody = GetComponent&lt;RigidBody2D&gt;();" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="The GetComponent function attempts to find a component on the current game object and returns it, the ‘&lt;&gt;’ are used to tell Unity what kind of component we are trying to get. Lastly, we store the RigidBody2D as a variable with the same name as the component (this is its class type) and name it something meaningful, in this case we can just name it rigidbody.&#10;&#10;Now lets get on with moving the player, with the rigid body we can do a few things to affect movement, mainly apply forces and set velocities. For now lets look at the apply forces option." name="Label" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="rigidbody.AddForce(Vector2.right * 5, ForceMode2D.Force);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="Breaking this down:&#10;&#x9;We are calling the AddForce function of the rigidbody component.&#10;&#x9;We are passing in 2 parameters, a force and force mode.&#10;&#x9;The force is a vector facing right with a magnitude of 5.&#10;&#x9;Lastly, the force mode is just force. (You can ignore this for now)&#10;&#10;When this function is called, the player will gain a burst of speed in the rightward direction as if pushed. We can change this speed by altering the direction and magnitude of the vector we pass in.&#10;&#10;Have a go now at using both the Input.GetKey function and the add force function to get the player moving based on player input. &#10;&#10;‘If’ you struggle, this sentence starts with a hint!&#10;" name="Label" enable-rich-text="true" />
                </ui:Tab>
                <ui:Tab label="Task 4" name="4-Parenting">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label name="Objective" text="Task Objective: Get the camera to follow the player, and fix the rotation issue" class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label name="Label" text="Your player should be moving now, however it keeps spinning around and going off screen!&#10;To solve this we are going to want to have the camera follow the player.&#10;&#10;This can be solved either by writing a custom script to move the camera, or more easily for our example parenting it to the player.&#10;Parenting GameObjects can be done by dragging one object onto another, in the same way as you would move one folder into another in the file explorer.&#10;&#10;Once parented, any transform that is applied to the parent is also applied to its children.&#10;So as the player moves, so does the camera!&#10;&#10;Try this and see what its like before coming back and reading the rest of this task!&#10;&#10;Seems pretty good right? Right???&#10;Well no, what we have is close to what we want, but the problem is that since the player is rotating the camera does too which can be somewhat dizzying.&#10;&#10;Lets look back at our player and solve this problem their.&#10;On the rigidbody2D component we can block / &quot;constrain&quot; specific properties of the rigidbodies motion. In this case we want to block rotations around the Z axis.&#10;&#10;Just give that a tick and see how things are!&#10;&#10;Remeber, you can change the behaviour of a component a lot from just altering its properties in the inspector, once your introduced to a few more components I do suggest having a play with them and seeing what you can do!" />
                </ui:Tab>
                <ui:Tab label="Task 5" name="5-Tags">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label name="Objective" text="Task Objective: Add a tag to the ghost and respawn the player on touching it." class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="Now that you have fixed the camera issues, we can visually see the player moving around.&#10;Most of you may have noticed we now get stuck in this little hole with the ghost moving back and forth. &#10;&#10;Before we get to working on adding a jump button (if you haven’t done this already). Lets try and make the ghost dangerous!&#10;&#10;Just as we did the player, we are going to want to add a new BoxCollider2D to the ghost. Unlike the player however, we are going to want to modify this component in the inspector by setting it to be a “trigger”.&#10;&#10;Trigger colliders do not interact with the physics system of the rigidbody2D, and are instead used call functions.&#10;&#10;Lets go to the player class and add a new function called OnTriggerEnter2D." />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="public void OnTriggerEnter2D(Collider2D other)" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="OnTriggerEnter2D takes a parameter of a Collider2D, this is a reference to the BoxCollider2D component that currently sits on the ghost. Since all components have a reference to the GameObject they sit on, we can actually output the name of the ghost on the collision as follows." />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text=" public void OnTriggerEnter2D(Collider2D other)&#10; {&#10; &#x9;Debug.Log(other.gameObject.name);&#10; } " name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="If you can see that the name of the ghost is appearing in the console then everything should be working!&#10;&#10;This is great, however we wanted to make the ghost kill the player not have them say their name.&#10;To do this we can “re-spawn” the player by just teleporting them back to the start.&#10;&#10;This can be done using the players transform component. (Which represents their position, rotation and scale. All GameObjects have one).&#10;&#10;This can either be done using “GetComponent&lt;Transform&gt;()” like we did with the rigidbody, or we can just write “transform” and have it automatically (Unity has something called an auto-property with effectively turns transform into “GetComponent&lt;Transform&gt;()” when called). &#10;&#10;To save you teleporting the player around the level aimlessly, the coordinates you will want to teleport them too are as follows:" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="transform.position = new Vector3(-3.25f, 1.25f, 0);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="That’s -5 on the X, -1 on the Y, and 0 on the Z (remember Unity is a technically still a 3D game engine even when we do things only in 2D).&#10;&#10;While we are at it, we can also reset the rigidbodies velocity to zero too, this will stop the player sliding off after dying if they died with momentum." />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="rigidbody.linearVelocity = new Vector3(0, 0, 0);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="What we now have is a very basic, but functional respawn system.&#10;&#10;Their is one final thing we need to add…&#10;&#10;Right now, if we collide with any trigger we will die, which is fine if we are only going to have hazards in the level. But if we want to have coins, other collectables or even doors that we can go into using triggers each of these will kill us.&#10;&#10;The solution is to just test what we actually hit when we enter the OnTriggerEnter2D function, and choose the behaviour from their. Do we kill the player, do we add a coin to the counter or something else entirely.&#10;&#10;We could do this with the game objects names, however if we have multiple hazards that would get quite cumbersome. Instead we can use tags!&#10;&#10;At the top of the inspector on the ghost, you can see Tag and Layer drop downs. Selecting the Tag drop-down and choose Add New, then create a new Tag. Call it something like “Hazards” or “Danger”. We can give this to anything that can kill the player.&#10;&#10;After making this you may need to re-assign it on the ghost (Unity is a bit awkward and even if you Add New from an object Unity wont realise that after you create the tag you wanted to add it too, its dumb I know…)&#10;&#10;With the ghost tagged, we can then test for this tag using:" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="if (other.gameObject.tag == &quot;Hazard&quot;) // Or the name of whatever you called the tag&#10;{&#10;        &#10;}" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" enable-rich-text="true" text="Move the re-spawning code now into this if statements block and give it a test!" />
                </ui:Tab>
                <ui:Tab label="Infomation" name="Infomation">
                    <ui:Label name="Label" text="Right now we have a somewhat functioning game, before we continue I just wanted to remind you about rendering.&#10;The camera is rendering the scene, but for things to be visible they need to tell the camera what they look like.&#10;&#10;In our case given where making a 2D game, we are using a SpriteRenderer component, which takes an image and draws it to the screen.&#10;If we where looking into a 3D game we would use MeshRenderers and MeshFilters.&#10;&#10;Were soon going to start looking into customising some of the GameObjects in the scene with sounds, but while doing this if you wanted to add in some of your own sprites just drag a .png file into the project windows (where the assets are) and then into the scene!" />
                </ui:Tab>
                <ui:Tab label="Task 6" name="6-Audio">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label name="Objective" text="Task Objective: Add audio effects for the ghost and the players death" class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label name="Label" text="As of right now the game has been silent. Lets change that.&#10;Their are two things we need to get audio working in Unity: an AudioListener component; and an AudioSource component.&#10;&#10;AudioListeners act as the ears for our player, this is important to know when considering how audio changes based on location or distance. This location is dependent on the transform of the object the AudioListener sits on. " />
                    <ui:VisualElement name="Warning" class="warning-container" style="flex-grow: 1; border-left-color: rgb(224, 210, 140); border-right-color: rgb(224, 210, 140); border-top-color: rgb(224, 210, 140); border-bottom-color: rgb(224, 210, 140); border-left-width: 5px; padding-left: 25px; margin-top: 15px; margin-right: 15px; margin-bottom: 15px; margin-left: 15px;">
                        <ui:Label text="There should only ever be one AudioListener in the scene" style="background-color: rgba(204, 185, 92, 0); color: rgb(224, 210, 140);" />
                    </ui:VisualElement>
                    <ui:Label name="Label" text="AudioSources are what produce the sounds, they take an AudioClip (.mp3, .wave. Etc.) and play it at the location of the AudioSources GameObject.&#10;&#10;We are going to look into adding in 2 audio clips. The first a looping ghost sound. The second the sound of the player dying.&#10;&#10;Starting off, to add an AudioListner to the player and an AudioSource to the ghost. Once this is done, drag the ghost sound effect from the project window (Found in Assets/Audio Clips/ghost.mp3) and into the audio clip field of the AudioSource.&#10;&#10;Pressing play, you should now be able to hear the ghost! Though this will only play the sound effect once and never again. To fix this, toggle the loop field in inspector on the AudioSource component.&#10;&#10;Now we will look into making the death sound.&#10;Were going to do a different approach here and play it through our player script.&#10;&#10;Add a new AudioSource to the player and add in the “ouch” sound effect to the audio clip field. Make sure “Play On Awake” is toggled to false, we don’t want to hear the players death sound on startup.&#10;&#10;Now that we have this, like with the RigidBody2D we can use GetComponent to retreive a reference to the AudioSource and then call its Play() function to play the audio. " />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="AudioSource audioSource = GetComponent&lt;AudioSource&gt;();&#10;audioSource.Play();" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label name="Label" text="Were going to want to put this next to the re-spawn code so that it plays when the player dies." />
                </ui:Tab>
                <ui:Tab label="Task 7" name="7-Jumping">
                    <ui:VisualElement class="task-objective-container">
                        <ui:Label name="Objective" text="Task Objective: Implement Jumping" class="task-objective" style="align-items: center; flex-grow: 0;" />
                    </ui:VisualElement>
                    <ui:Label name="Label" text="By now you should have almost everything you need to be able to implement jumping.&#10;The one thing you might be missing is a way to determine if the player is grounded. &#10;&#10;Right now if you have implemented a way of jumping using AddForce and GetButtonDown, you may have noticed you can jump in the air. &#10;This is where were going to want to add a way to check if the player is grounded if so then move the player, if not then skip.&#10;&#10;Their are a couple of differnt ways of doing this in Unity: trigger colliders; tracking player velocity; but for this task, where going to look into Raycasting.&#10;&#10;Raycasting is the act of firing a ray (line) from a point in a direction and determining if it has hit anything.&#10;We can use this by shooting a ray from the players feet downwards and determining if it has hit anything, if so we can consider the player grounded and let them jump.&#10;&#10;If your struggling to determine where the ray needs to be placed you can use the OnDrawGizmos function, and can call Gizmos.DrawLine(....)" />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="public void OnDrawGizmos()&#10;{&#10;        Vector3 rayOrigin = transform.position + new Vector3(0, 0, 0);&#10;        Vector3 rayDirection = new Vector3(0, -1f, 0);&#10;        float distance = 0.1f;&#10;        &#10;        Gizmos.DrawLine(rayOrigin, rayOrigin + rayDirection * distance);&#10;}" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:VisualElement name="Warning" class="warning-container" style="flex-grow: 1; border-left-color: rgb(224, 210, 140); border-right-color: rgb(224, 210, 140); border-top-color: rgb(224, 210, 140); border-bottom-color: rgb(224, 210, 140); border-left-width: 5px; padding-left: 25px; margin-top: 15px; margin-right: 15px; margin-bottom: 15px; margin-left: 15px;">
                        <ui:Label text="If you cannot see your gizmos, they may be disabled. Gizmos are only visibile if they are enabled at the top of the window." name="Label" style="background-color: rgba(204, 185, 92, 0); color: rgb(224, 210, 140);" />
                    </ui:VisualElement>
                    <ui:Label text="Once your happy with the positions and direction of the ray you can use them inside the Raycast function as followd: " />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="Vector3 rayOrigin = transform.position + new Vector3(0, 0, 0);&#10;Vector3 rayDirection = new Vector3(0, -1f, 0);&#10;float distance = 0.1f;&#10;&#10;RaycastHit2D hit = Physics2D.Raycast(rayOrigin, rayDirection, distance);&#10;if (hit)&#10;{&#10;    &#x9;Debug.Log($&quot;Name: {hit.collider.gameObject.name}&quot;);&#10;}" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="This may work, and it may not, the problem now is that Raycast has no knowledge on what we are actually hitting, only if we have hit something.&#10;As such you may experiance false positives where the ray is actually hitting the players collider and not the floor.&#10;&#10;To solve this, we can either use a layer mask (layer masks let us only test physics on specific objects) or we can check what objects we have hit from the hit variable from the output of the raycast function.&#10;" />
                    <ui:Label text="For now though, we will look at layers and layer masks. I have already created a physics layer for &quot;Floor&quot; and set it as the physics layer of all the floor GameObjects.&#10;What you will need to do is create the mask in script, and then pass it to the Raycast as an optional parameter at the end." />
                    <ui:VisualElement name="CodeContainer" class="code-block" style="flex-grow: 1;">
                        <ui:Label text="LayerMask mask = LayerMask.GetMask(&quot;Floor&quot;);&#10;RaycastHit2D hit = Physics2D.Raycast(rayOrigin, rayDirection, distance, mask);" name="Code" class="code" />
                    </ui:VisualElement>
                    <ui:Label text="From this you should now be able to tie this all together to get jumping working only while on the floor.&#10;When you do this, you may notice the jump doesn&apos;t give much speed. Try swapping the ForceMode from Force to Impulse (this is better for an sudden imidiate boost in speed)." />
                    <ui:VisualElement name="Warning" class="warning-container" style="flex-grow: 1; border-left-color: rgb(224, 210, 140); border-right-color: rgb(224, 210, 140); border-top-color: rgb(224, 210, 140); border-bottom-color: rgb(224, 210, 140); border-left-width: 5px; padding-left: 25px; margin-top: 15px; margin-right: 15px; margin-bottom: 15px; margin-left: 15px;">
                        <ui:Label text="There is ALOT covered here in a very short amount of time, if you have any questions, do do some googling and look into the Unity docs. &#10;Elsewise ask me any question you may have!" name="Label" style="background-color: rgba(204, 185, 92, 0); color: rgb(224, 210, 140);" />
                    </ui:VisualElement>
                </ui:Tab>
                <ui:Tab label="Final" name="Final">
                    <ui:Label text="You&apos;ve effectively gone over most of the basics now for being able to make a simple platformer. &#10;&#10;Feel free to either keep playing around with this demo project, make some new enemies or just expand the level out a bit!&#10;&#10;I’ve included some coins, a key and some spikes. Try and make it so you can pick these up, and or make it so the spikes can kill the player too!" name="Label" />
                </ui:Tab>
            </ui:TabView>
        </ui:ScrollView>
    </ui:VisualElement>
</ui:UXML>
